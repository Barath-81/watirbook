# Installation 

Because Watir is a Ruby library, you have to install Ruby first.

For Windows, there is one click installer. Ruby is probably already installed on Mac and Linux. Type `ruby -v` in command prompt to see if you have it installed. On Mac it will look something like this:

    $ ruby -v
    ruby 1.8.6 (2008-08-11 patchlevel 287) [universal-darwin9.0]

If you get an error message, please go to Ruby web site and follow instruction how to install it.

Ruby 1.8.6 is recommended on all platforms.

Ruby has a package system called Ruby gems, and Watir is released as a gem. 

Watir installation is different on each operating system. Only Firefox is available for all major operating systems, and other browsers are available only on some platforms. Hence, you can not install all browser drivers on all platforms.

Depending of your platform, there are a few choices. On all platforms, you have to update Ruby gems first.

On Windows:

    gem update --system

On Mac and Linux:

    sudo gem update --system

If Ruby gems are already up to date, you will get a message saying: `Nothing to update`.

The next step is installing Watir.

On Windows:

    gem install watir

It will install drivers for Internet Explorer and Firefox.

On Mac:

    sudo gem install firewatir
    sudo gem install safariwatir

The first line will install driver for Firefox, and the second one for Safari. If you plan to use only one driver, feel free to install only one.

On Linux:

    sudo gem install firewatir

Firefox drivers need JSSH extension for Firefox installed. You can find it at Watir wiki.

Driver for Chrome is installed with:

    gem install chromewatir

It works only on Windows. I did not put it in Windows section, because it is broken at the moment due to some changes in Chrome 3. It should be fixed soon.

It is not required, but I would highly recommend to install a browser extension like Internet Explorer Developer Toolbar of Firebug for Firefox. It will make your testing much more enjoying activity.

Internet Explorer 8 and Apple Safari are shipped with such a tool already installed.

# Watir in Five Minutes

`An example would be handy right about now` Brian Marick would say. Five minutes from now, you will be crazy about Watir. If not, maybe it is not the right tool for you. Even then, if you continue reading the book, I hope you will grow to like it the more you know about it.

In the rest of the book, I will explain all Watir functionality in great (maybe even painful) detail, but for now, I just want to show off a few cool features, to get you excited about it.

I still remember how pleasantly surprised I was the first time I saw Watir at work. I installed it, and in a few hours I was able to create a script that would log me in web application I was testing. Since you have this book you will be able to log in to your web site in minutes, not hours.

If you are familiar with Ruby, I am sure you already think IRB is one of the greatest tools for learning a new Ruby library.

If you are new to Ruby, you are probably thinking: `What is this IRB thing?`

IRB (in this case) does not stand for `International Rugby Board` or `Immigration or Refugee Board` (of Canada). It stands for `Interactive Ruby Shell`. Think of it as a shell that knows Ruby (as the name says).

To start IRB, just type `irb` in command line. You will see something like this (on Mac):

    $ irb
    >> 

Now you can enter any Ruby command and you will immediately get a result. We will start with telling Ruby that we want to use a library called Watir.

If you are on Windows, and would like to drive Internet Explorer, type this:

    require "watir"

If you are on a Mac, and would like to drive Safari, type this:

    require "safariwatir"

On any platform, if you would like to drive Firefox:

    require "firewatir"

You should see something like this:

    > require "safariwatir"
    => true

Every Ruby command returns something. `=> true` is what is returned after `require "safariwatir"`. There are two parts in the returned line. `=>` looks like an arrow, it tells you `Ruby returned this`. `true` is what is actually returned. When `true` is returned, it usually means that everything is fine.

Until I say differently, just ignore what is returned.

And now the magic starts. With just one command you will open a browser.

Internet Explorer:

    browser = Watir::IE.new

Firefox:

    browser = FireWatir::Firefox.new

Safari:

    browser = Watir::Safari.new

When I saw the browser magically appearing for the first time, only one thought crossed my mind: `Cool!`

Please open just one browser. It will be enough. You can play with other browsers later. All code that follows should work no matter which browser you have opened. Some features are not implemented in all browsers, and I will explicitly say it when we get to such a feature.

Output should be similar to this:

    >> browser = Watir::Safari.new
    => #<Watir::Safari:0x605054 @scripter=#<Watir::AppleScripter:0x604cd0 @typing_lag=0.08, @document=app("/Applications/Safari.app").documents[1], @appname="Safari", @js=#<Watir::JavaScripter:0x604d48>, @app=app("/Applications/Safari.app")>>

As I said earlier, you can ignore `#<Watir::Safari:0x605054...>`. Opening Safari returned the browser as an object, and this is textual representation of the object. I hope it will be changed to something less verbose in the near future.

Just opening a browser is cool, but not so useful. Watir can do so much more. For example, it can navigate the browser to any site. I will use pragprog.com in this example. I suggest that you literally follow the example, and then try a few sites yourself.

So, go to pragprog.com:

    >> browser.goto "http://pragprog.com"
    => nil

And pragprog.com opens. Magic, isn't it?

Controlling the browser is really useful but, as I am sure you already know, there is more to testing than just performing the actions. You have to check what happened after the action. What happens when I enter a URL in browser address bar, when I click a link or a button, when I enter some text in a text field or select something from select box...?

This is the first time we will perform a check. It is also the first time we will care what Ruby returns after the command. Let's check if the browser really opened pragprog.com.

    >> browser.url
    => "http://pragprog.com/"

It really works! Ruby returned a string (the thing in double quotes, remember?) that contains text from the browser address bar.

Time to click a link. It is easy to explicitly say which link to click. Right now I want to click a link with text `Books`. (It gets just a bit more complicated if there are two links with the same text on the page, but we will deal with that later.)

    >> browser.link(:text, "Books").click
    => nil

This time, let's check the page title.

    >> browser.title
    => "The Pragmatic Bookshelf | Our Titles"

We got back the string with the page title.

I want books to be sorted by category, so I have to click `By Category`. It is hard to say how it is implemented by just looking at it. It is the time to fire up your favorite page inspector tool. If you are using Safari on Mac, you already have one installed.

Right click `By Category` and select `Inspect Element` from context menu. This line will be highlighted in Inspector:

    <span>By Category</span>

That means we need to click a span with text `By Category`.

    >> browser.span(:text, "By Category").click
    => nil

Just for a second, take a closer look at this two commands that we used to click the link and the span:

    browser.link(:text, "Books"      ).click
    browser.span(:text, "By Category").click

They are almost identical. String (in double quotes) that we used to identify the link and the span are, of course, different. In the first example there is `link`, in the second one, there is `span`. The rest is the same. That is on purpose. You will appreciate that later.

Let's try to find all Ruby related books. There is a search box. Right click it and select `Inspect Element` from context menu. This line will be highlighted in Inspector:

    <input class="textbox narrow" id="q" name="q" type="text">

So it is a text box (that is pretty obvious) with and id attribute is `q`. If an element has an id attribute, you should use it.

    >> browser.text_field(:id, "q").set "ruby"
    => :missing_value

You can even see how Watir is typing each letter. Watir is just great in impressing people.

To perform search, we have to click `Go`. Right click it and select `Inspect Element`. I guess you already know what to do. You will see:

    <button class="go" type="submit">

No id this time, but there is class attribute. Watir is just great with real world web applications. If developers can create an element, Watir will have a way to access it.

    >> browser.button(:class, "go").click
    => nil

This time, let's check a lot of stuff. Is there text `151 results matching 'ruby'` on the page?

    >> browser.text.include?("151 results matching 'ruby'")
    => true

This time we asked Ruby if page text included a string, and it said `true`. It is it's cute way of saying `yes`. When asking the question we were even polite, please notice question mark in `include?`.

Is the text we have entered in the search box at the previous page still there? (This feature is not implemented for Safari yet. It works in Internet Explorer and Firefox. It should be implemented for Safari soon.)

    >> browser.text_field(:id, "q").value
    => "ruby"

Ruby returned text from the text field. It is the same text we entered, so everything is fine.

Let's check if there is a link to `Programming Ruby`:

    >> browser.link(:text, "Programming Ruby").exists?
    => true

If you are not impressed by now, you probably never will. But wait, it is time to bring on heavy artillery. Let's go deeper.

# HTML Elements Supported by Watir

Watir can access following HTML elements (alphabetically):

    <area>
    <a>
    <button>
    <dd>
    <div>
    <dl>
    <dt>
    <em>
    <form>
    <frame>
    <h1>
    <h2>
    <h3>
    <h4>
    <h5>
    <h6>
    <iframe>
    <img>
    <input type="button">
    <input type="checkbox">
    <input type="file">
    <input type="hidden">
    <input type="image">
    <input type="password">
    <input type="radio">
    <input type="reset">
    <input type="submit">
    <input type="text">
    <input>
    <label>
    <li>
    <map>
    <p>
    <pre>
    <select>
    <span>
    <strong>
    <table>
    <tbody>
    <td>
    <textarea>
    <tr>
    <ul>


If that is not enough for you, Watir also has XPath support. You can use it to access any HTML element.

# Link

Let's take a closer look at one element. I think you will use links the most, so it would be just fair to start there.

Usually, you can recognize a link on a web page because it's text is underlined:

    Programming Ruby: The Pragmatic Programmers' Guide, Second Edition

HTML code of a link could look something like this:

    <a href="http://www.pragprog.com/titles/ruby/programming-ruby">Programming Ruby: The Pragmatic Programmers' Guide, Second Edition</a>

You could access the link in a lot of ways.

Link can be accessed with (alphabetically):

    after?
    class
    href
    url
    html
    id
    index
    name
    text
    xpath

and multiple attributes.

Index accepts only integer as a value. Xpath accepts only string. Multiple attributes accepts only hash. All other methods accept string, regular expression and hash. You should already know what a string is, we have used it already. If you do not know what integer, hash or regular expression are, do not worry. I will explain them enough for the examples, and I will point you to places where you can learn more.

Since this link has text and href attribute, we will start there.

## Text

For this example, we are interested only in text of the link.

    <a>Programming Ruby: The Pragmatic Programmers' Guide, Second Edition</a>

### Text and String

Let's start in the original Watir way, `link` method accepting two parameters. The first parameter is a symbol, the second one is a string. You will know something is a symbol because it starts with a colon, like `:text`. For now, consider symbol to be nothing more than a string written in a strange way.

    browser.link(:text, "Programming Ruby: The Pragmatic Programmers' Guide, Second Edition").click

`link` method also accepts a hash. Hash consists of two parts, key and value. In this case the key is a symbol and the value is a string. Between them is that familiar arrow.

    browser.link(:text => "Programming Ruby: The Pragmatic Programmers' Guide, Second Edition").click

So, the only thing that is different between the two ways is that in the first example there is a comma between symbol and string, and in the second example there is and arrow. You will see why the arrow is introduced later.

In both examples we used a string to locate the link. We could do that because we knew the complete text of the link.

### Text and Regular expression

If you know only a portion of a string, you can use regular expression.

For now, think of regular expression as a portion of a string with a strange syntax. It looks like this: `/Programming Ruby/`.

We could know only the portion of a string if, for example, the string changed from time to time. For example, you want to click a discussion by title, but the title changes form `On Dogs (1)` to `On Dogs (2)` after the first reply is posted.

You could not use `"On Dogs"` to locate the link, because link text is `On Dogs (1)` and Watir will complain that it could not find it.

You could use `"On Dogs (1)"` to locate the link the first time, but when link text changes to `On Dogs (2)`, Watir will no longer be able to find the link.

In that case, you could say to Watir: `Well, I know the portion of the string.` and it will happily look at all strings until it finds the one that matches the portion you know.

In our example, we will use `/Programming Ruby/`. To click a link that has text `Programming Ruby`, use this (for now we do not care if there is any text before or after `Programming Ruby`):

    browser.link(:text, /Programming Ruby/).click

or

    browser.link(:text => /Programming Ruby/).click

## Href

For this example, let's look only at link's href attribute.

    <a href="http://www.pragprog.com/titles/ruby/programming-ruby"></a>

### Href and String

If you know the full value of link's href attribute, you could use `:href` symbol and a string to click the link.

    browser.link(:href, "http://www.pragprog.com/titles/ruby/programming-ruby").click

or

    browser.link(:href => "http://www.pragprog.com/titles/ruby/programming-ruby").click

### Href and Regular Expression

If you know only a portion of href attribute, you will still use `:href` to locate the link, but this time with an regular expression instead of a string.

    browser.link(:href, /programming-ruby/).click

or

    browser.link(:href => /programming-ruby/).click

## URL

Since href attribute points to an URL, you can use `:url` instead of `:href`.

    <a href="http://www.pragprog.com/titles/ruby/programming-ruby"></a>

### URL and String

    browser.link(:url, "http://www.pragprog.com/titles/ruby/programming-ruby").click

or

    browser.link(:url => "http://www.pragprog.com/titles/ruby/programming-ruby").click

### URL and Regular Expression


    browser.link(:url, /programming-ruby/).click

or

    browser.link(:url => /programming-ruby/).click

## ID

According to HTML specification, all HTML elements can have an id and each id should be unique on the page. Uniqueness makes id very convenient for us. All other element attributes can appear more than once on the page and Watir will locate only the first element with a specific attribute, and maybe we want the second or the third one. (There is workaround for that, keep on reading.)

So, if the link had an id attribute, like this:

    <a id="programming-ruby"></a>

we could access it using `:id`.

### ID and String

    browser.link(:id, "programming-ruby").click

or

    browser.link(:id => "programming-ruby").click

### ID and Regular Expression

    browser.link(:id, /programming-ruby/).click

or

    browser.link(:id => /programming-ruby/).click

## Name

Another attribute that almost all HTML elements can have is `name`. It is not supposed to be unique on the page. It is very common that elements that are somehow related on the page have the same name.

If it had a name attribute:

    <a name="programming-ruby"></a>

### Name and String

    browser.link(:name, "programming-ruby").click

or

    browser.link(:name => "programming-ruby").click

### Name and Regular expression

    browser.link(:name, /programming-ruby/).click

or

    browser.link(:name => /programming-ruby/).click

## Class

It is also very common for an HTML element to have a class attribute.

    <a class="book"></a>

### Class and String

    browser.link(:class, "book").click

or

    browser.link(:class => "book").click

### Class and Regular Expression

    browser.link(:class, /book/).click

or

    browser.link(:class => /book/).click

## Index

If you had no way other way, but you knew link's position on the page, you could use index. In this example, it is the first link.

    browser.link(:index, 1).click

or

    browser.link(:index => 1).click

Do you see anything strange in the above code? Take a look. I will wait.

Maybe you have noticed that this is the first time we did not use a string (double quotes around the text) or a regular expression (slashed around the text). We have used just the number one. Such numbers are called integers. Watir uses integers only with `:index`.

Please notice that the first link is accessed with the number one (that is called one-based indexing). It is usual in programming that the first element is the number zero (zero-based indexing). Watir will use zero-based indexing in Watir 2.0.

## After

Sometimes the only way to identify the element is to say that it should be after another element. Take a look at this example:

    <a>Programming Ruby</a>
    <div id="one" />
    <a>Programming Ruby</a>

You want to click the second link. This will click the first link, but we want to click the second one:

    browser.link(:text, "Programming Ruby").click

One of the ways you could do it is:

    browser.link(:after?, browser.div(:id, "one")).click

We said to Watir that we want to click a link after a div that has `id` attribute set to `one`. I rarely use it, but there are times when it is really handy.

Do you see something strange in the above code? This is the first time we have a syntax for accessing page element instead of strings or regular expressions.

## HTML

If the link you want to access does not have any usual attributes that could uniquely identify it, Watir can handle that too. For example, you need to click the second link:

    <a onclick="new Ajax.Request('001')">add</a>
    <a onclick="new Ajax.Request('007')">add</a>

One of the really elegant ways to do it is by using `:html`:

    browser.link(:html, /007/).click

In above example, we have used regular expression as a second parameter, but I am sure you have already got used to them. I am sure you are already convinced that regular expressions are very useful.

## XPath

XPath was not in Watir from the beginning. It was added by Angrez Singh. He also created Watir's Firefox driver. Aidy Lewis recently moved Watir's XPath from REXML to Nokogiri, and now it is faster. XPath is really powerful. Most times you can just use `:html`, but if it does not solve the problem, try XPath.

If you have a link:

    <a href="test.htm">click me</a>

You could click it with:

    browser.link(:xpath, "//a[@href='test.htm']/").click

or

    browser.link(:xpath => "//a[@href='test.htm']/").click

Another way, especially useful if the element you are trying to access in not directly supported by Watir:

    browser.element_by_xpath("//a[@href='test.htm']/").click

At the moment, you can use XPath to access elements located in a frame, but you can not use XPath to access the frame itself. In another words, this would work:

    browser.frame(:name, "one").link(:xpath, "//a[@href='test.htm']/").click

but this will not work:

    browser.frame(:xpath, "//frame[@name='one']/")

## Nested Elements

### Simple Nesting

Sometimes the only way to uniquely identify a link is to specify one or more of it's parent elements. How would you click the second link in this example?

    <div id="one">
      <a>Programming Ruby</a>
    </div>
    <div id="two">
      <a>Programming Ruby</a>
    </div>

This will click the first link, but we want to click the second one:

    browser.link(:text, "Programming Ruby").click

This will work, but it is really fragile:

    browser.link(:index, 2).click

If in further development a link (or more) is added between the two links we have so far, the code above will click what ever link was the second, and that is not what we want.

Let's make it less fragile.

We know that the second link is a child element of a div with an id. This is the solution to the problem:

    browser.div(:id, "two").link(:text, "Programming Ruby").click

Isn't that just so elegant?!

The above solution is not the only one. This will work too:

    browser.div(:id, "two").link(:index, 1).click

This time we said to Watir that we want it to click the first link in a specific div.

There are endless options how to click an element on a page, and this book will try to teach you all of them.

### More nesting

If for some reason you want to be very specific about where the element is located in the page, Watir can handle that too. For example, if you had something like this:

    <div id="one">
      <div id="two">
        <a>Programming Ruby</a>
      </div>
    </div>

You could click the link with:

    browser.div(:id, "one").div(:id, "two").link(:text, "Programming Ruby").click

The nesting can go as deep as you like.

## Multiple Attributes

Multiple attributes was also fairly recently added to Watir. It is a killer feature, as you will see. For example, if you have two completely identical links on the same page, and you want to click the second one:

      <a>Programming Ruby</a>
      <a>Programming Ruby</a>

you could do it with:

    browser.link(:text => "Programming Ruby", :index => 2).click

The above code will click the second link with text `Programming Ruby`.

## Collections

You can even do stuff with all elements of a particular kind on a page. If you want to check href attributes of all links in the page, this will do it:

    browser.links.each do |link|
      puts link.href
    end